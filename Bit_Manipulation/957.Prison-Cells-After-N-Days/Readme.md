### 957.Prison-Cells-After-N-Days

我们首先解决这个问题：从一个状态到下一个状态，如何高效地进行转换。用8个bit位来代表0/1是比较自然的想法。假设当前的状态用整形k来表示，下一个状态用k'来表示。我们发现，k'除去首尾，其余所有位置上，第i位的bit取决于上一个状态时第i-1位的bit是否和第i+1位的bit相等，即```bit(i)=~(bit(i-1)^bit(i+1))```。

我们将k右移一位记作k1，同时将k左移一位记作k2，我们将k1和k2对齐。我们发现，上述的操作就等价于```bit(k_i)=~(bit(k1_i)^bit(k2_i))```，也就是```k'=~(k1^k2)```。
```
k =   abcdefgh
k1 =  xabcdefg
k2 =  bcdefghx
```
另外注意，k'的首尾bit注定是0，所以我们额外加上需要加上一个```mask=01111110```来将首尾强制置为0.因此最终一次变换的表达式就是```k=~((k>>1)^(k<<1))&126```

接下来考虑，我们是否要真的做N次变换来得到最终结果呢？考虑到N的数量级很大，肯定是不合适的。我们发现，k总共8个bit位，除去首尾必须是0，那么总共只有2^6=64种可能。所以一定存在一个有限长度的循环节。我们最多模拟64个回合，就一定能找到循环节的起始点S和长度L。也就是说，从K0开始变换S次进入循环节，再变换L次就又重复这个循环节。

所以我们对于非常大的N，预处理为```N = (N-S)%L+S```。然后从K0开始，变换N次即可。
