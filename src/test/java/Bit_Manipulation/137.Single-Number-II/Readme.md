### 137.Single-Number-II

此题容易受到```136.Single-Number```的影响，总觉得应该用到“亦或”操作的性质。但事实上，此题的解法和^操作的关系并不大。

此题的突破点在于，细分到所有N个数的每个二进制位，都会有N-1个bit重复出现了3次，而有另一个bit出现了1次（这个bit就对应着那个single number）。如果把该二进制位上所有数的bit都相加起来，那么对3除的余数一定就是那个与众不同的bit。就这样，我们可以确定这个single number的每一位的bit，然后重构出对应的二进制数来。

实现上可以设计一个```vector<int>bits(32)```来累加每个二进制位的bit的总和。当然还有更省空间的方法。因为我们实际上只需要计算各个二进制位上bit之和除以3的余数，总共只有三种可能0,1,2.于是可以设计两个int32的计数器count1,count2. 其中count1[i]和count2[i]用来记录第i个二进制位上的bit之和，即00,01,11这三种情况。single number的每一个二进制位可以通过最终的count1[i]和count2[i]重构出来。
